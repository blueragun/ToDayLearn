# 그리디 : 현재 상황에서 지금당장 좋은 것만 고르는 방법

# 1. 거스름돈 문제
# 어떤 가격을 가진 물건을 구매하고 거스름돈이 k만큼 남았다. 이때 거스름돈을 주기위해 500, 100, 50, 10 있을 때
# 최소한의 동전갯수로 거스름돈을 줄 수 있는 갯수를 구하여라. 단 거슬러줘야 할 돈 k는 항상 10의 배수이다.

# 거스름돈
k = 1260

# 동전 갯수
count = 0 

# 큰 화폐부터 차례로 확인하기 위해 아래와 같이 리스트에 넣음
coin = [500, 100, 50, 10]

for i in coin :
  count += k // i  # K를 i로 나눈 몫을 동전갯수에 합산
  k %= i # k를 i로 나눈 나머지가 k가 된다
  
print(count) 


# 2. 큰수의 법칙
# 다양한 수로 이루어진 배열이 있을때 주어진 수들을 M번 더하여 가장 큰수를 만드는 법칙. 단, 배역의 특정한 인덱스에 해당하는 수가
# 연속적으로 K번을 초과하여 더해질 수 없다. 단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다.
# 첫줄에 N(2 <= N <= 1000), M(1 <= M <= 10000). K(1 <= K <= 10000)의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.
# 배열의 크기가 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질때 결과를 출력
# 입력예시
# 5 8 3
# 2 4 5 4 6

n, m, k = map(int, input().split()) 

data = list[map(int, input().split())]

data.sort()  # data에 들어있는 수를 정렬한다.
first_num = data[n-1]  # 가장 큰수
second_num = data[n-2] # 두번째 큰수

result = 0

while True :
  for i in range(k) :
    result += first_num
    m -= 1
    if m == 0 :
      break
  result += second_num
  m -= 1
  if  m == 0 :
    break

print(result)  